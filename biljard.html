<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Biljard</title>
<style>
:root {
--table-felt: #008080;
--table-rail: #8d6e63;
--background-start: #2a5298;
--background-end: #1e3c72;
--text-color: #ffffff;
--shadow-color: rgba(0, 0, 0, 0.3);
--button-bg: #ff6d00;
--button-hover-bg: #ff8124;
}
html,
body {
margin: 0;
padding: 0;
width: 100%;
height: 100vh;
overflow: hidden;
background: linear-gradient(to top, var(--background-start), var(--background-end));
display: flex;
justify-content: center;
align-items: top;
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
color: var(--text-color);
}
#game-area {
display: flex;
flex-direction: column;
align-items: center;
justify-content: flex-start;
width: 100%;
height: 97vh;
position: relative;
}
#top-ui {
display: flex;
justify-content: space-between;
align-items: flex-start;
width: 100%;
max-width: 1200px;
padding: 10px 0;
flex-shrink: 0;
}
.pocketed-balls-area {
width: 30%;
min-height: 50px;
background: rgba(0, 0, 0, 0.2);
border-radius: 8px;
padding: 8px;
box-sizing: border-box;
transition: all 0.3s ease;
}
.pocketed-balls-area h3 {
margin: 0 0 8px 0;
font-size: clamp(0.8rem, 2vw, 0.9rem);
text-align: center;
}
.pocketed-balls-container {
display: flex;
flex-wrap: wrap;
gap: 5px;
min-height: 25px;
}
.pocketed-ball-display {
width: 20px;
height: 20px;
border-radius: 50%;
background-color: white;
box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.5);
}
.pocketed-ball-display.stripe {
background-image: repeating-linear-gradient(-45deg,
white,
white 5px,
var(--stripe-color) 5px,
var(--stripe-color) 10px);
}
#header {
text-align: center;
color: var(--text-color);
text-shadow: 0 2px 4px var(--shadow-color);
flex-shrink: 0;
width: 40%;
position: relative;
}
#game-title {
font-size: clamp(1.2rem, 3vw, 2rem);
margin: 0 0 5px 0;
}
#game-status {
font-size: clamp(0.9rem, 2vw, 1.2rem);
min-height: 1.5em;
margin-top: 5px;
}
#canvas-container {
background: var(--table-rail);
padding: 15px;
border-radius: 15px;
box-shadow: 0 10px 30px var(--shadow-color);
}
canvas {
display: block;
background: var(--table-felt);
border-radius: 10px;
cursor: crosshair;
}
.game-button {
background-color: var(--button-bg);
color: var(--text-color);
border: none;
border-radius: 8px;
padding: 10px 20px;
font-size: clamp(1rem, 2.5vw, 1.2rem);
font-weight: bold;
cursor: pointer;
box-shadow: 0 4px 15px var(--shadow-color);
transition: all 0.2s ease-in-out;
}
.game-button:hover {
background-color: var(--button-hover-bg);
transform: translateY(-2px);
}
#play-again-btn {
position: absolute;
top: 120px;
left: 50%;
transform: translateX(-50%);
z-index: 100;
display: none;
}
#how-to-play-btn {
padding: 6px 12px;
font-size: clamp(0.8rem, 1.5vw, 0.9rem);
margin-bottom: 5px;
}
#rules-modal {
display: none;
position: fixed;
z-index: 200;
left: 0;
top: 0;
width: 100%;
height: 100%;
overflow: auto;
background-color: rgba(0, 0, 0, 0.6);
padding-top: 10px;
}
.modal-content {
background: linear-gradient(to bottom, var(--background-start), var(--background-end));
margin: 0% auto;
padding: 25px;
border: 1px solid var(--table-rail);
border-radius: 10px;
width: 100%;
max-width: 800px;
position: relative;
}
.modal-content h2 {
margin-top: 0;
color: var(--button-bg);
}
.modal-content p,
.modal-content li {
line-height: 1.6;
}
.close-btn {
color: #aaa;
position: absolute;
top: 10px;
right: 25px;
font-size: 35px;
font-weight: bold;
cursor: pointer;
}
.close-btn:hover,
.close-btn:focus {
color: white;
}
h1 {
font-size: 1rem;
margin-top: 6px;
margin-bottom: 0;
}
</style>
</head>
<body>
<div id="rules-modal">
<div class="modal-content">
<span class="close-btn">×</span>
<h2>Spilleregler for Biljard</h2>
<p><strong>Mål:</strong> Vær den første spilleren til å senke alle dine tildelte kuler (hel- eller stripete kuler) og deretter senke 8-ballen lovlig.</p>
<h3>Kontroller</h3>
<p>Dra musen på bordet for å sikte og sette kraft. Den hvite stiplede linjen viser hvor køballen vil gå, og den gule linjen viser retningen objektballen vil ta. Jo lenger du drar, desto hardere blir støtet. Slipp museknappen for å skyte.</p>
<h3>Spillets Gang</h3>
<ul>
<li>
<strong>Tildeling av grupper:</strong> Bordet er "åpent" i starten. Den første spilleren som lovlig senker en kule, vil bli tildelt den kulens gruppe (f.eks. senk en helfarget kule for å bli helfarget).
</li>
<li>
<strong>Turer:</strong> Du fortsetter turen din så lenge du lovlig senker en av dine egne kuler.
</li>
<li>
<strong>Feil (Foul):</strong> Hvis du gjør en feil, avsluttes turen din, og motstanderen får "ball i hånd". Feil inkluderer:
<ul>
<li>Å senke køballen (en "scratch").</li>
<li>Treffe motstanderens kule eller 8-ballen før din egen.</li>
<li>Ikke treffe noen kule med køballen.</li>
<li>Etter kontakt, hvis ingen kule senkes, må en kule (hvilken som helst kule) treffe en vant (vegg).</li>
</ul>
</li>
<li><strong>Ball i hånd:</strong> Etter en feil kan motstanderen plassere køballen hvor som helst på bordet. Hvis feilen skjer på åpningsstøtet, må plasseringen være bak baulk-linjen (den fjerdedelen av bordet der spillet starter).</li>
<li>
<strong>Seier/Tap:</strong> Du vinner ved å senke 8-ballen etter at alle dine andre kuler er borte. Du taper hvis du senker 8-ballen for tidlig eller gjør en feil (scratch) på det siste 8-ball-støtet.
</li>
</ul>
</div>
</div>
<div id="game-area">
<div id="top-ui">
<div id="player-pocketed-area" class="pocketed-balls-area">
<h3>Spillerens Kuler</h3>
<div id="player-pocketed-container" class="pocketed-balls-container"></div>
</div>
<div id="header">
<button id="how-to-play-btn" class="game-button">Spilleregler</button>
<p id="game-status">Setter opp bordet...</p>
<button id="play-again-btn" class="game-button">Spill Igjen</button>
</div>
<div id="ai-pocketed-area" class="pocketed-balls-area">
<h3>AI-ens Kuler</h3>
<div id="ai-pocketed-container" class="pocketed-balls-container"></div>
</div>
</div>
<div id="canvas-container">
<canvas id="pool-canvas"></canvas>
</div>
</div>
<script>
window.addEventListener('load', () => {
const canvas = document.getElementById('pool-canvas');
const ctx = canvas.getContext('2d');
const statusDisplay = document.getElementById('game-status');
const playerPocketedContainer = document.getElementById('player-pocketed-container');
const aiPocketedContainer = document.getElementById('ai-pocketed-container');
const playAgainBtn = document.getElementById('play-again-btn');
const rulesModal = document.getElementById('rules-modal');
const howToPlayBtn = document.getElementById('how-to-play-btn');
const closeModalBtn = document.querySelector('.close-btn');
let balls = [],
pockets = [];
const player = { name: 'Spiller', ballType: null };
const ai = { name: 'AI', ballType: null };
let gameState = 'LOADING';
class Vector {
constructor(x = 0, y = 0) { this.x = x; this.y = y; }
add(v) { return new Vector(this.x + v.x, this.y + v.y); }
subtract(v) { return new Vector(this.x - v.x, this.y - v.y); }
multiply(s) { return new Vector(this.x * s, this.y * s); }
magnitude() { return Math.sqrt(this.x ** 2 + this.y ** 2); }
normalize() { const m = this.magnitude(); return m > 0 ? new Vector(this.x / m, this.y / m) : new Vector(); }
dot(v) { return this.x * v.x + this.y * v.y; }
}
class Ball {
constructor(pos, number) {
this.pos = pos;
this.vel = new Vector();
this.number = number;
this.radius = 0;
this.isSunk = false;
this.hitRail = false;
if (number === 0) this.type = 'cue';
else if (number === 8) this.type = '8ball';
else if (number > 0 && number < 8) this.type = 'solid';
else if (number > 8 && number <= 15) this.type = 'stripe';
else this.type = 'invalid';
this.baseColor = this.getColor();
this.displayColor = this.baseColor;
}
getColor() {
const colors = { 0: '#ffffff', 1: '#ffca28', 2: '#2962ff', 3: '#d50000', 4: '#6200ea', 5: '#ff6d00', 6: '#00c853', 7: '#c51162', 8: '#212121', 9: '#ffca28', 10: '#2962ff', 11: '#d50000', 12: '#6200ea', 13: '#ff6d00', 14: '#00c853', 15: '#c51162' };
return colors[this.number] || '#ff00ff';
}
draw() {
if (this.isSunk || this.type === 'invalid') return;
ctx.save();
ctx.shadowColor = 'rgba(0,0,0,0.3)';
ctx.shadowBlur = this.radius * 0.3;
ctx.shadowOffsetX = this.radius * 0.1;
ctx.shadowOffsetY = this.radius * 0.2;
ctx.beginPath();
ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
ctx.fillStyle = this.displayColor;
if (this.type === 'cue' && gameState === 'BALL_IN_HAND' && Game.currentPlayer === player) { ctx.globalAlpha = 0.7; }
ctx.fill();
ctx.globalAlpha = 1;
if (this.type === 'stripe') {
ctx.fillStyle = 'white';
ctx.save();
ctx.clip();
ctx.fillRect(this.pos.x - this.radius, this.pos.y - this.radius * 0.5, this.radius * 2, this.radius);
ctx.restore();
}
let shadeGradient = ctx.createRadialGradient(this.pos.x, this.pos.y, this.radius * 0.1, this.pos.x, this.pos.y, this.radius);
shadeGradient.addColorStop(0, 'rgba(0,0,0,0.05)');
shadeGradient.addColorStop(0.7, 'rgba(0,0,0,0.3)');
shadeGradient.addColorStop(1, 'rgba(0,0,0,0.5)');
ctx.fillStyle = shadeGradient;
ctx.fill();
let highlightGradient = ctx.createRadialGradient(this.pos.x - this.radius * 0.4, this.pos.y - this.radius * 0.5, this.radius * 0.05, this.pos.x, this.pos.y, this.radius);
highlightGradient.addColorStop(0, 'rgba(255,255,255,0.7)');
highlightGradient.addColorStop(0.3, 'rgba(255,255,255,0)');
ctx.fillStyle = highlightGradient;
ctx.fill();
ctx.restore();
}
}
class Pocket {
constructor(pos, isCorner) { this.pos = pos; this.isCorner = isCorner; this.radius = 0; }
draw() {
ctx.beginPath();
ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
ctx.fillStyle = 'rgba(0,0,0,0.5)';
ctx.fill();
}
}
const Physics = {
shotData: {},
update(deltaTime) {
if (!deltaTime || deltaTime <= 0) return;
const timeCorrection = deltaTime * 60;
const iterations = 5;
for (let iter = 0; iter < iterations; iter++) {
balls.forEach(b => { if (!b.isSunk) b.pos = b.pos.add(b.vel.multiply(timeCorrection / iterations)); });
this.handleCollisions();
}
balls.forEach(b => {
const friction = Math.pow(0.985, timeCorrection);
b.vel = b.vel.multiply(friction);
if (b.vel.magnitude() < 0.05) b.vel = new Vector();
});
},
handleCollisions() {
for (let i = 0; i < balls.length; i++) {
for (let j = i + 1; j < balls.length; j++) {
const b1 = balls[i]; const b2 = balls[j];
if (b1.isSunk || b2.isSunk) continue;
const distVec = b1.pos.subtract(b2.pos);
const dist = distVec.magnitude();
if (dist < b1.radius + b2.radius) {
if ((b1.type === 'cue' || b2.type === 'cue') && !this.shotData.firstHit) { this.shotData.firstHit = b1.type === 'cue' ? b2 : b1; }
const normal = distVec.normalize();
const overlap = b1.radius + b2.radius - dist;
b1.pos = b1.pos.add(normal.multiply(overlap / 2));
b2.pos = b2.pos.subtract(normal.multiply(overlap / 2));
const tangent = new Vector(-normal.y, normal.x);
const v1n = b1.vel.dot(normal); const v1t = b1.vel.dot(tangent);
const v2n = b2.vel.dot(normal); const v2t = b2.vel.dot(tangent);
const v1nFinal = v2n; const v2nFinal = v1n;
const v1nVec = normal.multiply(v1nFinal); const v1tVec = tangent.multiply(v1t);
const v2nVec = normal.multiply(v2nFinal); const v2tVec = tangent.multiply(v2t);
b1.vel = v1nVec.add(v1tVec); b2.vel = v2nVec.add(v2tVec);
}
}
}
balls.forEach(b => {
if (b.isSunk) return;
pockets.forEach(p => { if (b.pos.subtract(p.pos).magnitude() < p.radius) { b.isSunk = true; b.vel = new Vector(); this.shotData.sunkBalls.push(b); } });
if (b.isSunk) return;
const railRestitution = -0.85;
if ((b.pos.x < b.radius) || (b.pos.x > canvas.width - b.radius)) {
b.pos.x = b.pos.x < b.radius ? b.radius : canvas.width - b.radius;
b.vel.x *= railRestitution;
if (!b.hitRail) { this.shotData.hitRailAfterContact = true; b.hitRail = true; }
}
if ((b.pos.y < b.radius) || (b.pos.y > canvas.height - b.radius)) {
b.pos.y = b.pos.y < b.radius ? b.radius : canvas.height - b.radius;
if (!b.hitRail) { this.shotData.hitRailAfterContact = true; b.hitRail = true; }
b.vel.y *= railRestitution;
}
});
},
isMoving() { return balls.some(b => !b.isSunk && b.vel.magnitude() > 0.05); }
};
const Game = {
currentPlayer: player, isTableOpen: true, isBreakShot: true, animationFrame: null, lastTime: 0,
initializeTable() {
const w = canvas.width, h = canvas.height;
const ballRadius = w / 48;
pockets = [];
const cornerPocketMargin = ballRadius * 0.5; const sidePocketOffset = ballRadius * 0.2;
pockets.push(new Pocket(new Vector(cornerPocketMargin, cornerPocketMargin), true), new Pocket(new Vector(w / 2, -sidePocketOffset), false), new Pocket(new Vector(w - cornerPocketMargin, cornerPocketMargin), true), new Pocket(new Vector(cornerPocketMargin, h - cornerPocketMargin), true), new Pocket(new Vector(w / 2, h + sidePocketOffset), false), new Pocket(new Vector(w - cornerPocketMargin, h - cornerPocketMargin), true));
pockets.forEach(p => { p.radius = p.isCorner ? ballRadius * 1.6 : ballRadius * 1.7; });
balls = [];
balls.push(new Ball(new Vector(w / 4, h / 2), 0));
const shuffleArray = a => { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } };
let numberedBalls = Array.from({ length: 15 }, (_, i) => i + 1).filter(n => n !== 8);
shuffleArray(numberedBalls);
const rackOrder = [numberedBalls[0], numberedBalls[1], numberedBalls[2], 8, numberedBalls[3], numberedBalls[4], numberedBalls[5], numberedBalls[6], numberedBalls[7], ...numberedBalls.slice(8)];
const solids = rackOrder.filter(n => n < 8); const stripes = rackOrder.filter(n => n > 8);
const finalRack = new Array(15);
finalRack[0] = rackOrder.find(n => n < 8 && n > 0); finalRack[4] = 8; finalRack[10] = solids.pop(); finalRack[14] = stripes.pop();
const remainingSolids = solids.filter(n => n !== finalRack[0] && n !== finalRack[10]);
const remainingStripes = stripes.filter(n => n !== finalRack[14]);
const remainingNumbers = [...remainingSolids, ...remainingStripes];
shuffleArray(remainingNumbers);
for (let i = 0, numIdx = 0; i < 15; i++) { if (typeof finalRack[i] === 'undefined') { finalRack[i] = remainingNumbers[numIdx++]; } }
let idx = 0; const startX = w * 0.7; const squeezeFactor = 0.998;
for (let i = 0; i < 5; i++) {
for (let j = 0; j <= i; j++) {
const num = finalRack[idx++]; if (typeof num === 'undefined') continue;
balls.push(new Ball(new Vector(startX + i * (ballRadius * 2 * Math.sqrt(3) / 2 * squeezeFactor), h / 2 + j * (ballRadius * 2 * squeezeFactor) - i * (ballRadius * squeezeFactor)), num));
}
}
balls.forEach(b => { b.radius = ballRadius; b.isSunk = false; b.vel = new Vector(); });
},
startNewGame() {
playAgainBtn.style.display = 'none';
player.ballType = null; ai.ballType = null;
this.currentPlayer = player; this.isTableOpen = true; this.isBreakShot = true;
this.initializeTable();
this.updateStatus('Spiller: Spre kulene!');
this.updatePocketedDisplay();
gameState = 'AWAITING_INPUT';
if (!this.animationFrame) { this.lastTime = 0; this.animationFrame = requestAnimationFrame(t => this.loop(t)); }
},
loop(currentTime) {
if (gameState === 'GAME_OVER') { this.animationFrame = null; return; }
if (!this.lastTime) this.lastTime = currentTime;
const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 1 / 30);
this.lastTime = currentTime;
if (gameState === 'SHOT_IN_PROGRESS') Physics.update(deltaTime);
if (gameState === 'BALL_IN_HAND' && this.currentPlayer === player) Input.handleBallInHand();
this.draw();
if (gameState === 'SHOT_IN_PROGRESS' && !Physics.isMoving()) { this.evaluateTurn(); }
this.animationFrame = requestAnimationFrame(t => this.loop(t));
},
draw() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
if ((gameState === 'BALL_IN_HAND' || gameState === 'AWAITING_INPUT') && this.isBreakShot) {
ctx.save(); ctx.beginPath(); ctx.moveTo(canvas.width / 4, 0); ctx.lineTo(canvas.width / 4, canvas.height);
ctx.setLineDash([5, 10]); ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 1; ctx.stroke();
ctx.restore();
}
pockets.forEach(p => p.draw());
balls.forEach(b => b.draw());
Input.drawAimLine();
},
evaluateTurn() {
const { firstHit, sunkBalls, hitRailAfterContact } = Physics.shotData;
const sunk8Ball = sunkBalls.some(b => b.type === '8ball');
const sunkCueBall = sunkBalls.some(b => b.type === 'cue');
let foul = false;
if (sunkCueBall) foul = true;
else if (!firstHit) foul = true;
else if (this.isTableOpen) {
if (firstHit.type === '8ball') foul = true;
} else {
const remainingTargetBalls = balls.filter(b => b.type === this.currentPlayer.ballType && !b.isSunk).length;
if (firstHit.type === '8ball' && remainingTargetBalls > 0) { foul = true; }
else if (firstHit.type !== this.currentPlayer.ballType && firstHit.type !== '8ball') { foul = true; }
}
if (sunkBalls.length === 0 && firstHit && !hitRailAfterContact) { foul = true; }
if (sunk8Ball) {
const remaining = balls.filter(b => b.type === this.currentPlayer.ballType && !b.isSunk).length;
if (foul || this.isTableOpen || (remaining > 0 && !this.isBreakShot)) { this.endGame(this.getOpponent(), `vinner fordi ${this.currentPlayer.name} senket 8-ballen ulovlig`); }
else { this.endGame(this.currentPlayer, 'vinner!'); }
return;
}
if (foul) { this.handleFoul(this.isBreakShot); return; }
let legalPot = false;
const targetSunkBalls = sunkBalls.filter(b => b.type === 'solid' || b.type === 'stripe');
if (this.isTableOpen && targetSunkBalls.length > 0) {
const firstSunkType = targetSunkBalls[0].type;
this.currentPlayer.ballType = firstSunkType;
this.getOpponent().ballType = firstSunkType === 'solid' ? 'stripe' : 'solid';
this.isTableOpen = false;
const ballTypeNorwegian = this.currentPlayer.ballType === 'solid' ? 'hele' : 'striper';
this.updateStatus(`${this.currentPlayer.name} har nå ${ballTypeNorwegian}.`);
legalPot = true;
} else if (!this.isTableOpen && sunkBalls.some(b => b.type === this.currentPlayer.ballType)) { legalPot = true; }
this.updatePocketedDisplay();
this.isBreakShot = false;
if (legalPot) { this.continueTurn(); }
else { this.switchTurn(false); }
},
handleFoul(isBreakFoul) { this.updateStatus(`Feil! ${this.getOpponent().name} får ballen i hånden.`); const cueBall = balls.find(b => b.type === 'cue'); if (cueBall.isSunk) { cueBall.isSunk = false; } this.switchTurn(true, isBreakFoul); },
continueTurn() { this.updateStatus(`${this.currentPlayer.name} sin tur. Bra støt!`); gameState = 'AWAITING_INPUT'; if (this.currentPlayer === ai) { setTimeout(() => AI.takeShot(), 1000); } },
switchTurn(isFoul = false, isBreakFoul = false) {
this.currentPlayer = this.getOpponent();
if (isFoul) {
gameState = 'BALL_IN_HAND'; Input.isBreakShotPlacement = isBreakFoul;
this.updateStatus(`${this.currentPlayer.name}: Plasser køballen.`);
if (this.currentPlayer === ai) { setTimeout(() => AI.placeBall(isBreakFoul), 500); }
} else {
gameState = 'AWAITING_INPUT'; this.updateStatus(`${this.currentPlayer.name} sin tur.`);
if (this.currentPlayer === ai) { setTimeout(() => AI.takeShot(), 1000); }
}
},
endGame(winner, reason) { gameState = 'GAME_OVER'; this.updateStatus(`Spillet er over! ${winner.name} ${reason}`); this.updatePocketedDisplay(); playAgainBtn.style.display = 'block'; },
getOpponent() { return this.currentPlayer === player ? ai : player; },
updateStatus(text) { statusDisplay.textContent = text; },
updatePocketedDisplay() {
playerPocketedContainer.innerHTML = ''; aiPocketedContainer.innerHTML = '';
balls.forEach(ball => {
if (ball.isSunk && (ball.type === 'solid' || ball.type === 'stripe')) {
const ballDiv = document.createElement('div'); ballDiv.className = 'pocketed-ball-display'; let ownerContainer = null;
if (player.ballType === ball.type) ownerContainer = playerPocketedContainer; else if (ai.ballType === ball.type) ownerContainer = aiPocketedContainer;
if (ownerContainer) {
if (ball.type === 'stripe') { ballDiv.classList.add('stripe'); ballDiv.style.setProperty('--stripe-color', ball.baseColor); } else { ballDiv.style.backgroundColor = ball.baseColor; }
ownerContainer.appendChild(ballDiv);
}
}
});
},
handleResize() {
const gameArea = document.getElementById('game-area'); const topUI = document.getElementById('top-ui'); const canvasContainer = document.getElementById('canvas-container');
const topUIHeight = topUI.offsetHeight;
const availableHeight = gameArea.clientHeight - topUIHeight - 20; const availableWidth = gameArea.clientWidth - 40;
const oldWidth = canvas.width; const oldHeight = canvas.height;
let tableWidth = availableWidth * 0.95; let tableHeight = tableWidth / 2;
if (tableHeight > availableHeight) { tableHeight = availableHeight; tableWidth = tableHeight * 2; }
canvasContainer.style.width = `${tableWidth}px`;
canvas.width = tableWidth; canvas.height = tableHeight;
if (balls.length > 0 && pockets.length > 0) {
const w = canvas.width, h = canvas.height; const ballRadius = w / 48; const cornerPocketMargin = ballRadius * 0.5; const sidePocketOffset = ballRadius * 0.2;
pockets[0].pos = new Vector(cornerPocketMargin, cornerPocketMargin); pockets[1].pos = new Vector(w / 2, -sidePocketOffset); pockets[2].pos = new Vector(w - cornerPocketMargin, cornerPocketMargin);
pockets[3].pos = new Vector(cornerPocketMargin, h - cornerPocketMargin); pockets[4].pos = new Vector(w / 2, h + sidePocketOffset); pockets[5].pos = new Vector(w - cornerPocketMargin, h - cornerPocketMargin);
pockets.forEach(p => { p.radius = p.isCorner ? ballRadius * 1.6 : ballRadius * 1.7; });
balls.forEach(b => { if (!b.isSunk) { b.pos.x = b.pos.x * (w / oldWidth); b.pos.y = b.pos.y * (h / oldHeight); } b.radius = ballRadius; });
}
this.draw();
}
};
const Input = {
isAiming: false, mousePos: new Vector(), isBreakShotPlacement: true,
init() {
canvas.addEventListener('mousemove', e => (this.mousePos = this.getMousePos(e)));
canvas.addEventListener('mousedown', e => {
if (gameState === 'BALL_IN_HAND' && Game.currentPlayer === player) {
const cueBall = balls[0];
if (cueBall.displayColor === cueBall.baseColor) { gameState = 'AWAITING_INPUT'; Game.updateStatus('Spiller sin tur.'); this.isBreakShotPlacement = false; }
return;
}
if (gameState === 'AWAITING_INPUT' && Game.currentPlayer === player) this.isAiming = true;
});
canvas.addEventListener('mouseup', e => {
if (!this.isAiming) return;
this.isAiming = false; const cueBall = balls[0];
const powerVec = this.mousePos.subtract(cueBall.pos);
if (powerVec.magnitude() < 10) return;
gameState = 'SHOT_IN_PROGRESS';
Physics.shotData = { sunkBalls: [], firstHit: null, hitRailAfterContact: false };
balls.forEach(b => (b.hitRail = false));
const power = Math.min(powerVec.magnitude() / 5, 40);
cueBall.vel = powerVec.normalize().multiply(power);
});
},
getMousePos(e) { const rect = canvas.getBoundingClientRect(); return new Vector(e.clientX - rect.left, e.clientY - rect.top); },
handleBallInHand() {
if (Game.currentPlayer !== player) return;
let newPos = this.mousePos; const cueBall = balls[0]; const r = cueBall.radius;
const maxX = this.isBreakShotPlacement ? (canvas.width / 4) - r : canvas.width - r;
newPos.x = Math.max(r, Math.min(maxX, newPos.x));
newPos.y = Math.max(r, Math.min(canvas.height - r, newPos.y));
cueBall.pos = newPos;
let overlap = balls.slice(1).some(b => !b.isSunk && cueBall.pos.subtract(b.pos).magnitude() < r * 2);
cueBall.displayColor = overlap ? '#ff4d4d' : cueBall.baseColor;
},
drawAimLine() {
if (!this.isAiming || gameState !== 'AWAITING_INPUT') return;
const cueBall = balls[0];
if (this.mousePos.subtract(cueBall.pos).magnitude() < 10) return;
ctx.save(); ctx.beginPath(); ctx.moveTo(cueBall.pos.x, cueBall.pos.y); ctx.lineTo(this.mousePos.x, this.mousePos.y);
ctx.setLineDash([5, 10]); ctx.strokeStyle = 'rgba(255,255,255,0.7)'; ctx.lineWidth = 2; ctx.stroke();
ctx.restore();
const aimDir = this.mousePos.subtract(cueBall.pos).normalize();
let closestHit = { dist: Infinity, ball: null };
for (const ball of balls) {
if (ball.isSunk || ball.number === 0) continue;
const ballToCue = ball.pos.subtract(cueBall.pos);
const proj = ballToCue.dot(aimDir);
if (proj <= 0) continue;
const perpDistSq = ballToCue.magnitude() ** 2 - proj ** 2;
const totalRadius = cueBall.radius + ball.radius;
if (perpDistSq < totalRadius ** 2) {
const distToImpact = proj - Math.sqrt(totalRadius ** 2 - perpDistSq);
if (distToImpact >= 0 && distToImpact < closestHit.dist) { closestHit = { dist: distToImpact, ball: ball }; }
}
}
if (closestHit.ball) {
const targetBall = closestHit.ball;
const cueImpactPos = cueBall.pos.add(aimDir.multiply(closestHit.dist));
const targetDir = targetBall.pos.subtract(cueImpactPos).normalize();
const startPoint = targetBall.pos;
const endPoint = startPoint.add(targetDir.multiply(targetBall.radius * 8));
ctx.save(); ctx.beginPath(); ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(endPoint.x, endPoint.y);
ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)'; ctx.lineWidth = 2; ctx.setLineDash([4, 4]); ctx.stroke();
ctx.restore();
}
}
};
const AI = {
isPathClear(startPos, endPos, ballToIgnore1, ballToIgnore2) {
const lineVec = endPos.subtract(startPos); const lineMagSq = lineVec.x ** 2 + lineVec.y ** 2;
for (const ball of balls) {
if (ball.isSunk || ball === ballToIgnore1 || ball === ballToIgnore2) continue;
const ballVec = ball.pos.subtract(startPos);
const t = ballVec.dot(lineVec) / lineMagSq;
if (t > 0.01 && t < 0.99) {
const closestPoint = startPos.add(lineVec.multiply(t));
const distSq = (closestPoint.x - ball.pos.x) ** 2 + (closestPoint.y - ball.pos.y) ** 2;
if (distSq < (ball.radius * 2.1) ** 2) return false;
}
}
return true;
},
takeShot() {
if (gameState !== 'AWAITING_INPUT' || Game.currentPlayer !== ai) return;
const bestShot = this.findBestShot();
if (bestShot && bestShot.aimPos) {
const finalDir = bestShot.aimPos.subtract(balls[0].pos).normalize();
balls[0].vel = finalDir.multiply(bestShot.power);
} else {
Game.updateStatus('AI gir opp og gir turen til deg.');
setTimeout(() => { Game.switchTurn(false); }, 1000);
return;
}
gameState = 'SHOT_IN_PROGRESS';
Physics.shotData = { sunkBalls: [], firstHit: null, hitRailAfterContact: false };
balls.forEach(b => (b.hitRail = false));
},
findBestShot() {
let bestShot = { score: -Infinity, target: null, pocket: null, aimPos: null, power: 0 };
const cueBall = balls[0];
let targetBalls = [];
if (Game.isTableOpen) {
targetBalls = balls.filter(b => !b.isSunk && b.type !== '8ball' && b.type !== 'cue');
} else {
targetBalls = balls.filter(b => b.type === ai.ballType && !b.isSunk);
if (targetBalls.length === 0) { targetBalls = balls.filter(b => b.type === '8ball' && !b.isSunk); }
}
if (targetBalls.length === 0) return null;
// FASE 1: Let etter DIREKTE skudd
for (const target of targetBalls) {
for (const pocket of pockets) {
let aimTargetPos = pocket.pos;
if (!pocket.isCorner) {
const nudge = target.radius * 0.5;
aimTargetPos = new Vector(pocket.pos.x, pocket.pos.y > canvas.height / 2 ? pocket.pos.y - nudge : pocket.pos.y + nudge);
}
const targetToPocketDir = aimTargetPos.subtract(target.pos).normalize();
const aimPos = target.pos.subtract(targetToPocketDir.multiply(cueBall.radius + target.radius));
if (!this.isPathClear(cueBall.pos, aimPos, cueBall, target)) continue;
if (!this.isPathClear(target.pos, aimTargetPos, target, cueBall)) continue;
const cueToAimDir = aimPos.subtract(cueBall.pos).normalize();
const angleBonus = cueToAimDir.dot(targetToPocketDir);
if (angleBonus < 0.05) continue;
let score = 1000 + (1 / (cueBall.pos.subtract(aimPos).magnitude() + target.pos.subtract(pocket.pos).magnitude())) * 200 + angleBonus * 100;
if (target.type === '8ball') score *= 2;
if (score > bestShot.score) {
const power = Math.min(10 + (cueBall.pos.subtract(aimPos).magnitude() + target.pos.subtract(pocket.pos).magnitude()) / 30, 35);
bestShot = { score, target, pocket, aimPos, power };
}
}
}
if (bestShot.score === -Infinity) {
const rails = [ { y: 0 }, { y: canvas.height }, { x: 0 }, { x: canvas.width }];
for (const target of targetBalls) {
for (const pocket of pockets) {
for (const rail of rails) {
let virtualPocketPos;
if (rail.y !== undefined) { virtualPocketPos = new Vector(pocket.pos.x, 2 * rail.y - pocket.pos.y); }
else { virtualPocketPos = new Vector(2 * rail.x - pocket.pos.x, pocket.pos.y); }
const targetToVirtualPocket = virtualPocketPos.subtract(target.pos);
const totalDist = targetToVirtualPocket.magnitude();
const distToRail = (rail.y !== undefined) ? Math.abs(target.pos.y - rail.y) : Math.abs(target.pos.x - rail.x);
const bankPoint = target.pos.add(targetToVirtualPocket.multiply(distToRail / totalDist));
const targetToBankDir = bankPoint.subtract(target.pos).normalize();
const aimPos = target.pos.subtract(targetToBankDir.multiply(cueBall.radius + target.radius));
if (!this.isPathClear(cueBall.pos, aimPos, cueBall, target)) continue;
if (!this.isPathClear(target.pos, bankPoint, target, cueBall)) continue;
const cueToAimDir = aimPos.subtract(cueBall.pos).normalize();
const angleBonus = cueToAimDir.dot(targetToBankDir);
if (angleBonus < 0.1) continue; // Vær litt mer kresen på vall-støt
// Vall-støt får lavere score slik at de er Plan B
let score = 500 + (1 / totalDist) * 100 + angleBonus * 50;
if (target.type === '8ball') score *= 2;
if (score > bestShot.score) {
Game.updateStatus("AI vurderer et vall-støt...");
const power = Math.min(15 + totalDist / 25, 40);
bestShot = { score, target, pocket, aimPos, power };
}
}
}
}
}
// FASE 3: Hvis ingenting annet fungerer, spill posisjonelt
if (bestShot.score === -Infinity) {
Game.updateStatus('AI finner ingen gode hull. Spiller posisjonelt.');
for (const target of targetBalls) {
const tableCenter = new Vector(canvas.width / 2, canvas.height / 2);
const targetToCenterDir = tableCenter.subtract(target.pos).normalize();
const aimPos = target.pos.add(targetToCenterDir.multiply(cueBall.radius + target.radius));
if (!this.isPathClear(cueBall.pos, aimPos, cueBall, target)) continue;
const cueToTargetDist = cueBall.pos.subtract(target.pos).magnitude();
const score = 200 - cueToTargetDist;
if (score > bestShot.score) { bestShot = { score, target, pocket: null, aimPos, power: 15 }; }
}
}
return bestShot.score > -Infinity ? bestShot : null;
},
placeBall(isBreakFoul) {
let bestPlacement = { score: -Infinity, position: null };
const cueBall = balls[0];
const originalPos = cueBall.pos;
const step = cueBall.radius * 3;
const startX = cueBall.radius;
const endX = isBreakFoul ? canvas.width / 4 - cueBall.radius : canvas.width - cueBall.radius;
for (let x = startX; x < endX; x += step) {
for (let y = cueBall.radius; y < canvas.height; y += step) {
const testPos = new Vector(x, y);
if (balls.slice(1).some(b => !b.isSunk && testPos.subtract(b.pos).magnitude() < cueBall.radius * 2.1)) continue;
cueBall.pos = testPos;
const shot = this.findBestShot();
if (shot && shot.score > bestPlacement.score) { bestPlacement = { score: shot.score, position: testPos }; }
}
}
cueBall.pos = bestPlacement.position || new Vector(isBreakFoul ? canvas.width / 8 : canvas.width * 0.75, canvas.height / 2);
gameState = 'AWAITING_INPUT';
Game.updateStatus('AI-en sin tur.');
setTimeout(() => this.takeShot(), 1000);
},
};
playAgainBtn.addEventListener('click', () => Game.startNewGame());
howToPlayBtn.addEventListener('click', () => (rulesModal.style.display = 'block'));
closeModalBtn.addEventListener('click', () => (rulesModal.style.display = 'none'));
window.addEventListener('click', e => { if (e.target == rulesModal) rulesModal.style.display = 'none'; });
Input.init();
window.addEventListener('resize', () => Game.handleResize());
Game.handleResize();
Game.startNewGame();
});
</script>
</body>
</html>