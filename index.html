<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>8-Ball Pool</title>
<meta name="description" content="Challenge an AI opponent to a game of 8 Ball Pool (Billiards) in this free browser game.">
<meta name="author" content="Johnny Heggelund">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<style>
:root {
--table-felt: #008080;
--table-rail: #8d6e63;
--background-start: #2a5298;
--background-end: #1e3c72;
--text-color: #ffffff;
--shadow-color: rgba(0, 0, 0, 0.3);
--button-bg: #ff6d00;
--button-hover-bg: #ff8124;
}
html,
body {
margin: 0;
padding: 0;
width: 100%;
height: 100vh;
overflow: hidden;
background: linear-gradient(to top, var(--background-start), var(--background-end));
display: flex;
justify-content: center;
align-items: top;
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
color: var(--text-color);
}
#game-area {
display: flex;
flex-direction: column;
align-items: center;
justify-content: flex-start;
width: 100%;
height: 97vh;
position: relative;
}
#top-ui {
display: flex;
justify-content: space-between;
align-items: flex-start;
width: 100%;
max-width: 1200px;
padding: 10px 0;
flex-shrink: 0;
}
.pocketed-balls-area {
width: 30%;
min-height: 50px;
background: rgba(0, 0, 0, 0.2);
border-radius: 8px;
padding: 8px;
box-sizing: border-box;
transition: all 0.3s ease;
}
.pocketed-balls-area h3 {
margin: 0 0 8px 0;
font-size: clamp(0.8rem, 2vw, 0.9rem);
text-align: center;
}
.pocketed-balls-container {
display: flex;
flex-wrap: wrap;
gap: 5px;
min-height: 25px;
}
.pocketed-ball-display {
width: 20px;
height: 20px;
border-radius: 50%;
background-color: white;
box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.5);
}
.pocketed-ball-display.stripe {
background-image: repeating-linear-gradient(-45deg,
white,
white 5px,
var(--stripe-color) 5px,
var(--stripe-color) 10px);
}
#header {
text-align: center;
color: var(--text-color);
text-shadow: 0 2px 4px var(--shadow-color);
flex-shrink: 0;
width: 40%;
position: relative;
}
#game-title {
font-size: clamp(1.2rem, 3vw, 2rem);
margin: 0 0 5px 0;
}
#game-status {
font-size: clamp(0.9rem, 2vw, 1.2rem);
min-height: 1.5em;
margin-top: 5px;
}
#canvas-container {
background: var(--table-rail);
padding: 15px;
border-radius: 15px;
box-shadow: 0 10px 30px var(--shadow-color);
}
canvas {
display: block;
background: var(--table-felt);
border-radius: 10px;
cursor: crosshair;
}
.game-button {
background-color: var(--button-bg);
color: var(--text-color);
border: none;
border-radius: 8px;
padding: 10px 20px;
font-size: clamp(1rem, 2.5vw, 1.2rem);
font-weight: bold;
cursor: pointer;
box-shadow: 0 4px 15px var(--shadow-color);
transition: all 0.2s ease-in-out;
}
.game-button:hover {
background-color: var(--button-hover-bg);
transform: translateY(-2px);
}
#play-again-btn {
position: absolute;
top: 120px;
left: 50%;
transform: translateX(-50%);
z-index: 100;
display: none;
}
#how-to-play-btn {
padding: 6px 12px;
font-size: clamp(0.8rem, 1.5vw, 0.9rem);
margin-bottom: 5px;
}
#rules-modal {
display: none;
position: fixed;
z-index: 200;
left: 0;
top: 0;
width: 100%;
height: 100%;
overflow: auto;
background-color: rgba(0, 0, 0, 0.6);
padding-top: 10px;
}
.modal-content {
background: linear-gradient(to bottom, var(--background-start), var(--background-end));
margin: 0% auto;
padding: 25px;
border: 1px solid var(--table-rail);
border-radius: 10px;
width: 100%;
max-width: 800px;
position: relative;
}
.modal-content h2 {
margin-top: 0;
color: var(--button-bg);
}
.modal-content p,
.modal-content li {
line-height: 1.6;
}
.close-btn {
color: #aaa;
position: absolute;
top: 10px;
right: 25px;
font-size: 35px;
font-weight: bold;
cursor: pointer;
}
.close-btn:hover,
.close-btn:focus {
color: white;
}
h1 {
font-size: 1rem;
margin-top: 6px;
margin-bottom: 0;
}
</style>
</head>
<body>
<div id="rules-modal">
<div class="modal-content">
<span class="close-btn">&times;</span>
<h2>Billiards Game Rules</h2>
<p><strong>Goal:</strong> Be the first player to pocket all of your assigned balls (whole balls or striped balls) and then legally pocket the 8-ball.</p>
<h3>Controls</h3>
<p>Drag the mouse on the table to aim and set power. The white dotted line shows where the cue ball will go, and the yellow line shows the direction the object ball will take. The further you drag, the harder the impact. Release the mouse button to shoot.</p>
<h3>Game Rules</h3>
<ul>
<li>
<strong>Assign groups:</strong> The table is "open" at the start. The first player to legally pocket a ball will be assigned to that ball's group (e.g. pocket a whole ball to become whole balls).
</li>
<li>
<strong>Turns:</strong> You continue your turn as long as you legally pocket one of your own balls.
</li>
<li>
<strong>Foul:</strong> If you make a mistake, your turn ends and your opponent gets "ball in hand". Mistakes include:
<ul>
<li>Lowering the cue ball (a "scratch").</li>
<li>Hit your opponent's ball or the 8-ball before your own.</li>
<li>Do not hit any ball with the cue ball.</li>
<li>After contact, if no ball is dropped, a ball (any ball) must hit a wall.</li>
<li><strong>Ball in hand:</strong> After a fault, the opponent may place the cue ball anywhere on the table. If the fault occurs on the break shot, the placement must be behind the baulk line (the quarter of the table where play starts).</li>
</ul>
</li>
<li>
<strong>Win/Lose:</strong> You win by pocketing the 8-ball after all your other balls are gone. You lose if you pocket the 8-ball too early or make a mistake (scratch) on the last 8-ball shot.
</li>
</ul>
</div>
</div>
<div id="game-area">
<div id="top-ui">
<div id="player-pocketed-area" class="pocketed-balls-area">
<h3>Player's Balls</h3>
<div id="player-pocketed-container" class="pocketed-balls-container"></div>
</div>
<div id="header">
<button id="how-to-play-btn" class="game-button">Game rules</button>
<p id="game-status">Setting the table...</p>
<button id="play-again-btn" class="game-button">Play again</button>
</div>
<div id="ai-pocketed-area" class="pocketed-balls-area">
<h3>The AI's Balls</h3>
<div id="ai-pocketed-container" class="pocketed-balls-container"></div>
</div>
</div>
<div id="canvas-container">
<canvas id="pool-canvas"></canvas>
</div>
</div>
<script>
// STATS-FETCHER-START
fetch('https://www.chromebooker.com/stats/visitors.php', {
method: 'POST',
headers: {
'Content-Type': 'application/json'
},
body: JSON.stringify({ page: window.location.href })
});
// STATS-FETCHER-END
window.addEventListener('load', () => {
const canvas = document.getElementById('pool-canvas');
const ctx = canvas.getContext('2d');
const statusDisplay = document.getElementById('game-status');
const playerPocketedContainer = document.getElementById('player-pocketed-container');
const aiPocketedContainer = document.getElementById('ai-pocketed-container');
const playAgainBtn = document.getElementById('play-again-btn');
const rulesModal = document.getElementById('rules-modal');
const howToPlayBtn = document.getElementById('how-to-play-btn');
const closeModalBtn = document.querySelector('.close-btn');
let balls = [],
pockets = [];
const player = {
name: 'Player',
ballType: null
};
const ai = {
name: 'AI',
ballType: null
};
let gameState = 'LOADING';
class Vector {
constructor(x = 0, y = 0) {
this.x = x;
this.y = y;
}
add(v) {
return new Vector(this.x + v.x, this.y + v.y);
}
subtract(v) {
return new Vector(this.x - v.x, this.y - v.y);
}
multiply(s) {
return new Vector(this.x * s, this.y * s);
}
magnitude() {
return Math.sqrt(this.x ** 2 + this.y ** 2);
}
normalize() {
const m = this.magnitude();
return m > 0 ? new Vector(this.x / m, this.y / m) : new Vector();
}
dot(v) {
return this.x * v.x + v.y * this.y;
}
}
class Ball {
constructor(pos, number) {
this.pos = pos;
this.vel = new Vector();
this.number = number;
this.radius = 0;
this.isSunk = false;
this.hitRail = false;
if (number === 0) this.type = 'cue';
else if (number === 8) this.type = '8ball';
else if (number > 0 && number < 8) this.type = 'solid';
else if (number > 8 && number <= 15) this.type = 'stripe';
else this.type = 'invalid';
this.baseColor = this.getColor();
this.displayColor = this.baseColor;
}
getColor() {
const colors = {
0: '#ffffff',
1: '#ffca28',
2: '#2962ff',
3: '#d50000',
4: '#6200ea',
5: '#ff6d00',
6: '#00c853',
7: '#c51162',
8: '#212121',
9: '#ffca28',
10: '#2962ff',
11: '#d50000',
12: '#6200ea',
13: '#ff6d00',
14: '#00c853',
15: '#c51162'
};
return colors[this.number] || '#ff00ff';
}
draw() {
if (this.isSunk || this.type === 'invalid') return;
ctx.save();
ctx.shadowColor = 'rgba(0,0,0,0.3)';
ctx.shadowBlur = this.radius * 0.3;
ctx.shadowOffsetX = this.radius * 0.1;
ctx.shadowOffsetY = this.radius * 0.2;
ctx.beginPath();
ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
ctx.fillStyle = this.displayColor;
if (this.type === 'cue' && gameState === 'BALL_IN_HAND' && Game.currentPlayer === player) {
ctx.globalAlpha = 0.7;
}
ctx.fill();
ctx.globalAlpha = 1;
if (this.type === 'stripe') {
ctx.fillStyle = 'white';
ctx.save();
ctx.clip();
ctx.fillRect(this.pos.x - this.radius, this.pos.y - this.radius * 0.5, this.radius * 2, this.radius);
ctx.restore();
}
let shadeGradient = ctx.createRadialGradient(this.pos.x, this.pos.y, this.radius * 0.1, this.pos.x, this.pos.y, this.radius);
shadeGradient.addColorStop(0, 'rgba(0,0,0,0.05)');
shadeGradient.addColorStop(0.7, 'rgba(0,0,0,0.3)');
shadeGradient.addColorStop(1, 'rgba(0,0,0,0.5)');
ctx.fillStyle = shadeGradient;
ctx.fill();
let highlightGradient = ctx.createRadialGradient(this.pos.x - this.radius * 0.4, this.pos.y - this.radius * 0.5, this.radius * 0.05, this.pos.x, this.pos.y, this.radius);
highlightGradient.addColorStop(0, 'rgba(255,255,255,0.7)');
highlightGradient.addColorStop(0.3, 'rgba(255,255,255,0)');
ctx.fillStyle = highlightGradient;
ctx.fill();
ctx.restore();
}
}
class Pocket {
constructor(pos, isCorner) {
this.pos = pos;
this.isCorner = isCorner;
this.radius = 0;
}
draw() {
ctx.beginPath();
ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
ctx.fillStyle = 'rgba(0,0,0,0.5)';
ctx.fill();
}
}
const Physics = {
shotData: {},
update(deltaTime) {
if (!deltaTime || deltaTime <= 0) return;
const timeCorrection = deltaTime * 60;
const iterations = 4;
for (let iter = 0; iter < iterations; iter++) {
balls.forEach(b => {
if (!b.isSunk) b.pos = b.pos.add(b.vel.multiply(timeCorrection / iterations));
});
this.handleCollisions();
}
balls.forEach(b => {
const friction = Math.pow(0.98, timeCorrection);
b.vel = b.vel.multiply(friction);
if (b.vel.magnitude() < 0.05) b.vel = new Vector();
});
},
handleCollisions() {
for (let i = 0; i < balls.length; i++) {
for (let j = i + 1; j < balls.length; j++) {
const b1 = balls[i];
const b2 = balls[j];
if (b1.isSunk || b2.isSunk) continue;
const distVec = b1.pos.subtract(b2.pos);
const dist = distVec.magnitude();
if (dist < b1.radius + b2.radius) {
if ((b1.type === 'cue' || b2.type === 'cue') && !this.shotData.firstHit) {
this.shotData.firstHit = b1.type === 'cue' ? b2 : b1;
}
let normal = distVec.normalize();
const overlap = b1.radius + b2.radius - dist;
b1.pos = b1.pos.add(normal.multiply(overlap / 2));
b2.pos = b2.pos.subtract(normal.multiply(overlap / 2));
let cueBall = null, targetBall = null;
if (b1.type === 'cue') {
cueBall = b1;
targetBall = b2;
normal = normal.multiply(-1);
} else if (b2.type === 'cue') {
cueBall = b2;
targetBall = b1;
}
if (cueBall) {
const cueSpeed = cueBall.vel.magnitude();
const cueVelNormalComponent = cueBall.vel.dot(normal);
if (cueSpeed < 0.1 || cueVelNormalComponent <= 0) continue;
const energyTransfer = 0.85;
targetBall.vel = normal.multiply(cueSpeed * energyTransfer);
const cueVelTangentVec = cueBall.vel.subtract(normal.multiply(cueVelNormalComponent));
cueBall.vel = cueVelTangentVec.normalize().multiply(cueSpeed * (1 - energyTransfer));
} else {
const v1n = b1.vel.dot(normal);
const v2n = b2.vel.dot(normal);
const v1t = b1.vel.subtract(normal.multiply(v1n));
const v2t = b2.vel.subtract(normal.multiply(v2n));
b1.vel = v1t.add(normal.multiply(v2n));
b2.vel = v2t.add(normal.multiply(v1n));
}
}
}
}
balls.forEach(b => {
if (b.isSunk) return;
pockets.forEach(p => {
if (b.pos.subtract(p.pos).magnitude() < p.radius) {
b.isSunk = true;
b.vel = new Vector();
this.shotData.sunkBalls.push(b);
}
});
if (b.isSunk) return;
const railRestitution = -0.8;
if ((b.pos.x < b.radius) || (b.pos.x > canvas.width - b.radius)) {
b.pos.x = b.pos.x < b.radius ? b.radius : canvas.width - b.radius;
b.vel.x *= railRestitution;
if (!b.hitRail) {
this.shotData.hitRailAfterContact = true;
b.hitRail = true;
}
}
if ((b.pos.y < b.radius) || (b.pos.y > canvas.height - b.radius)) {
b.pos.y = b.pos.y < b.radius ? b.radius : canvas.height - b.radius;
b.vel.y *= railRestitution;
if (!b.hitRail) {
this.shotData.hitRailAfterContact = true;
b.hitRail = true;
}
}
});
},
isMoving() {
return balls.some(b => !b.isSunk && b.vel.magnitude() > 0.05);
}
};
const Game = {
currentPlayer: player,
isTableOpen: true,
isBreakShot: true,
animationFrame: null,
lastTime: 0,
initializeTable() {
const w = canvas.width,
h = canvas.height;
const ballRadius = w / 48;
pockets = [];
const cornerPocketMargin = ballRadius * 0.5;
const sidePocketOffset = ballRadius * 0.2;
pockets.push(
new Pocket(new Vector(cornerPocketMargin, cornerPocketMargin), true),
new Pocket(new Vector(w / 2, -sidePocketOffset), false),
new Pocket(new Vector(w - cornerPocketMargin, cornerPocketMargin), true),
new Pocket(new Vector(cornerPocketMargin, h - cornerPocketMargin), true),
new Pocket(new Vector(w / 2, h + sidePocketOffset), false),
new Pocket(new Vector(w - cornerPocketMargin, h - cornerPocketMargin), true)
);
pockets.forEach(p => {
p.radius = p.isCorner ? ballRadius * 1.6 : ballRadius * 1.7;
});
balls = [];
balls.push(new Ball(new Vector(w / 4, h / 2), 0));
const shuffleArray = (array) => {
for (let i = array.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[array[i], array[j]] = [array[j], array[i]];
}
};
let numberedBalls = Array.from({
length: 15
}, (_, i) => i + 1).filter(n => n !== 8);
shuffleArray(numberedBalls);
const rackOrder = [
numberedBalls[0],
numberedBalls[1], numberedBalls[2],
8, numberedBalls[3],
numberedBalls[4], numberedBalls[5],
numberedBalls[6], numberedBalls[7],
...numberedBalls.slice(8)
];
const solids = rackOrder.filter(n => n < 8);
const stripes = rackOrder.filter(n => n > 8);
const finalRack = new Array(15);
finalRack[0] = rackOrder.find(n => n < 8 && n > 0);
finalRack[4] = 8;
finalRack[10] = solids.pop();
finalRack[14] = stripes.pop();
const remainingSolids = solids.filter(n => n !== finalRack[0] && n !== finalRack[10]);
const remainingStripes = stripes.filter(n => n !== finalRack[14]);
const remainingNumbers = [...remainingSolids, ...remainingStripes];
shuffleArray(remainingNumbers);
for (let i = 0, numIdx = 0; i < 15; i++) {
if (typeof finalRack[i] === 'undefined') {
finalRack[i] = remainingNumbers[numIdx++];
}
}
let idx = 0;
const startX = w * 0.7;
const squeezeFactor = 0.998;
for (let i = 0; i < 5; i++) {
for (let j = 0; j <= i; j++) {
const num = finalRack[idx++];
if (typeof num === 'undefined') continue;
balls.push(
new Ball(
new Vector(
startX + i * (ballRadius * 2 * Math.sqrt(3) / 2 * squeezeFactor),
h / 2 + j * (ballRadius * 2 * squeezeFactor) - i * (ballRadius * squeezeFactor)
),
num
)
);
}
}
balls.forEach(b => {
b.radius = ballRadius;
b.isSunk = false;
b.vel = new Vector();
});
},
startNewGame() {
playAgainBtn.style.display = 'none';
player.ballType = null;
ai.ballType = null;
this.currentPlayer = player;
this.isTableOpen = true;
this.isBreakShot = true;
this.initializeTable();
this.updateStatus('Player: Spread balls!');
this.updatePocketedDisplay();
gameState = 'AWAITING_INPUT';
if (!this.animationFrame) {
this.lastTime = 0;
this.animationFrame = requestAnimationFrame(time => this.loop(time));
}
},
loop(currentTime) {
if (gameState === 'GAME_OVER') {
this.animationFrame = null;
return;
}
if (!this.lastTime) this.lastTime = currentTime;
const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 1 / 30);
this.lastTime = currentTime;
if (gameState === 'SHOT_IN_PROGRESS') Physics.update(deltaTime);
if (gameState === 'BALL_IN_HAND' && this.currentPlayer === player) Input.handleBallInHand();
this.draw();
if (gameState === 'SHOT_IN_PROGRESS' && !Physics.isMoving()) {
this.evaluateTurn();
}
this.animationFrame = requestAnimationFrame(time => this.loop(time));
},
draw() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
if ((gameState === 'BALL_IN_HAND' || gameState === 'AWAITING_INPUT') && this.isBreakShot) {
ctx.save();
ctx.beginPath();
ctx.moveTo(canvas.width / 4, 0);
ctx.lineTo(canvas.width / 4, canvas.height);
ctx.setLineDash([5, 10]);
ctx.strokeStyle = 'rgba(255,255,255,0.4)';
ctx.lineWidth = 1;
ctx.stroke();
ctx.restore();
}
pockets.forEach(p => p.draw());
balls.forEach(b => b.draw());
Input.drawAimLine();
},
evaluateTurn() {
const {
firstHit,
sunkBalls,
hitRailAfterContact
} = Physics.shotData;
const sunk8Ball = sunkBalls.some(b => b.type === '8ball');
const sunkCueBall = sunkBalls.some(b => b.type === 'cue');
let foul = false;
if (sunkCueBall) foul = true;
else if (!firstHit) foul = true;
else if (this.isTableOpen) {
if (firstHit.type === '8ball') foul = true;
} else {
if (firstHit.type !== this.currentPlayer.ballType && firstHit.type !== '8ball') foul = true;
}
if (sunkBalls.length === 0 && firstHit && !hitRailAfterContact) {
foul = true;
}
if (sunk8Ball) {
const remaining = balls.filter(b => b.type === this.currentPlayer.ballType && !b.isSunk).length;
if (foul || this.isTableOpen || (remaining > 0 && !this.isBreakShot)) {
this.endGame(this.getOpponent(), ``);
} else {
this.endGame(this.currentPlayer, '');
}
return;
}
if (foul) {
this.handleFoul(this.isBreakShot);
return;
}
let legalPot = false;
const targetSunkBalls = sunkBalls.filter(b => b.type === 'solid' || b.type === 'stripe');
if (this.isTableOpen && targetSunkBalls.length > 0) {
const firstSunkType = targetSunkBalls[0].type;
this.currentPlayer.ballType = firstSunkType;
this.getOpponent().ballType = firstSunkType === 'solid' ? 'stripe' : 'solid';
this.isTableOpen = false;
const ballTypeNorwegian = this.currentPlayer.ballType === 'solid' ? 'helballer' : 'stripeballer';
this.updateStatus(`${this.currentPlayer.name} is now ${ballTypeNorwegian}.`);
legalPot = true;
} else if (!this.isTableOpen && sunkBalls.some(b => b.type === this.currentPlayer.ballType)) {
legalPot = true;
}
this.updatePocketedDisplay();
this.isBreakShot = false;
if (legalPot) {
this.continueTurn();
} else {
this.switchTurn(false);
}
},
handleFoul(isBreakFoul) {
this.updateStatus(`Foul! ${this.getOpponent().name} gets ball in hand.`);
const cueBall = balls.find(b => b.type === 'cue');
if (cueBall.isSunk) {
cueBall.isSunk = false;
}
this.switchTurn(true, isBreakFoul);
},
continueTurn() {
this.updateStatus(`${this.currentPlayer.name}'s turn. Good shot!`);
gameState = 'AWAITING_INPUT';
if (this.currentPlayer === ai) {
setTimeout(() => AI.takeShot(), 1000);
}
},
switchTurn(isFoul = false, isBreakFoul = false) {
this.currentPlayer = this.getOpponent();
if (isFoul) {
gameState = 'BALL_IN_HAND';
Input.isBreakShotPlacement = isBreakFoul;
this.updateStatus(`${this.currentPlayer.name}: Place the cue ball.`);
if (this.currentPlayer === ai) {
setTimeout(() => AI.placeBall(isBreakFoul), 500);
}
} else {
gameState = 'AWAITING_INPUT';
this.updateStatus(`${this.currentPlayer.name}'s turn.`);
if (this.currentPlayer === ai) {
setTimeout(() => AI.takeShot(), 1000);
}
}
},
endGame(winner, reason) {
gameState = 'GAME_OVER';
const message = reason.includes('lovlig') ? `wins!` : `wins${reason}!`;
this.updateStatus(`Game over! ${winner.name} ${message}`);
this.updatePocketedDisplay();
playAgainBtn.style.display = 'block';
},
getOpponent() {
return this.currentPlayer === player ? ai : player;
},
updateStatus(text) {
statusDisplay.textContent = text;
},
updatePocketedDisplay() {
playerPocketedContainer.innerHTML = '';
aiPocketedContainer.innerHTML = '';
balls.forEach(ball => {
if (ball.isSunk && (ball.type === 'solid' || ball.type === 'stripe')) {
const ballDiv = document.createElement('div');
ballDiv.className = 'pocketed-ball-display';
let ownerContainer = null;
if (player.ballType === ball.type) ownerContainer = playerPocketedContainer;
else if (ai.ballType === ball.type) ownerContainer = aiPocketedContainer;
if (ownerContainer) {
if (ball.type === 'stripe') {
ballDiv.classList.add('stripe');
ballDiv.style.setProperty('--stripe-color', ball.baseColor);
} else {
ballDiv.style.backgroundColor = ball.baseColor;
}
ownerContainer.appendChild(ballDiv);
}
}
});
},
handleResize() {
const gameArea = document.getElementById('game-area');
const topUI = document.getElementById('top-ui');
const canvasContainer = document.getElementById('canvas-container');
const topUIHeight = topUI.offsetHeight;
const availableHeight = gameArea.clientHeight - topUIHeight - 20;
const availableWidth = gameArea.clientWidth - 40;
const oldWidth = canvas.width;
const oldHeight = canvas.height;
let tableWidth = availableWidth * 0.95;
let tableHeight = tableWidth / 2;
if (tableHeight > availableHeight) {
tableHeight = availableHeight;
tableWidth = tableHeight * 2;
}
canvasContainer.style.width = `${tableWidth}px`;
canvas.width = tableWidth;
canvas.height = tableHeight;
if (balls.length > 0 && pockets.length > 0) {
const w = canvas.width,
h = canvas.height;
const ballRadius = w / 48;
const cornerPocketMargin = ballRadius * 0.5;
const sidePocketOffset = ballRadius * 0.2;
pockets[0].pos = new Vector(cornerPocketMargin, cornerPocketMargin);
pockets[1].pos = new Vector(w / 2, -sidePocketOffset);
pockets[2].pos = new Vector(w - cornerPocketMargin, cornerPocketMargin);
pockets[3].pos = new Vector(cornerPocketMargin, h - cornerPocketMargin);
pockets[4].pos = new Vector(w / 2, h + sidePocketOffset);
pockets[5].pos = new Vector(w - cornerPocketMargin, h - cornerPocketMargin);
pockets.forEach(p => {
p.radius = p.isCorner ? ballRadius * 1.6 : ballRadius * 1.7;
});
balls.forEach(b => {
if (!b.isSunk) {
b.pos.x = b.pos.x * (w / oldWidth);
b.pos.y = b.pos.y * (h / oldHeight);
}
b.radius = ballRadius;
});
}
this.draw();
}
};
const Input = {
isAiming: false,
mousePos: new Vector(),
isBreakShotPlacement: true,
init() {
canvas.addEventListener('mousemove', e => (this.mousePos = this.getMousePos(e)));
canvas.addEventListener('mousedown', e => {
if (gameState === 'BALL_IN_HAND' && Game.currentPlayer === player) {
const cueBall = balls[0];
if (cueBall.displayColor === cueBall.baseColor) {
gameState = 'AWAITING_INPUT';
Game.updateStatus('Player\'s turn.');
this.isBreakShotPlacement = false;
}
return;
}
if (gameState === 'AWAITING_INPUT' && Game.currentPlayer === player) this.isAiming = true;
});
canvas.addEventListener('mouseup', e => {
if (!this.isAiming) return;
this.isAiming = false;
const cueBall = balls[0];
const powerVec = this.mousePos.subtract(cueBall.pos);
const MIN_DRAG_DISTANCE = 10;
if (powerVec.magnitude() < MIN_DRAG_DISTANCE) return;
gameState = 'SHOT_IN_PROGRESS';
Physics.shotData = {
sunkBalls: [],
firstHit: null,
hitRailAfterContact: false
};
balls.forEach(b => (b.hitRail = false));
const power = Math.min(powerVec.magnitude() / 5, 40);
cueBall.vel = powerVec.normalize().multiply(power);
});
},
getMousePos(e) {
const rect = canvas.getBoundingClientRect();
return new Vector(e.clientX - rect.left, e.clientY - rect.top);
},
handleBallInHand() {
if (Game.currentPlayer !== player) return;
let newPos = this.mousePos;
const cueBall = balls[0];
const r = cueBall.radius;
const maxX = this.isBreakShotPlacement ? (canvas.width / 4) - r : canvas.width - r;
newPos.x = Math.max(r, Math.min(maxX, newPos.x));
newPos.y = Math.max(r, Math.min(canvas.height - r, newPos.y));
cueBall.pos = newPos;
let overlap = balls.slice(1).some(b => !b.isSunk && cueBall.pos.subtract(b.pos).magnitude() < r * 2);
cueBall.displayColor = overlap ? '#ff4d4d' : cueBall.baseColor;
},
drawAimLine() {
if (!this.isAiming || gameState !== 'AWAITING_INPUT') return;
const cueBall = balls[0];
const powerVec = this.mousePos.subtract(cueBall.pos);
if (powerVec.magnitude() < 10) return;
ctx.save();
ctx.beginPath();
ctx.moveTo(cueBall.pos.x, cueBall.pos.y);
ctx.lineTo(this.mousePos.x, this.mousePos.y);
ctx.setLineDash([5, 10]);
ctx.strokeStyle = 'rgba(255,255,255,0.7)';
ctx.lineWidth = 2;
ctx.stroke();
ctx.restore();
const aimDir = this.mousePos.subtract(cueBall.pos).normalize();
let closestHit = { dist: Infinity, ball: null };
for (const ball of balls) {
if (ball.isSunk || ball.number === 0) continue;
const ballToCue = ball.pos.subtract(cueBall.pos);
const proj = ballToCue.dot(aimDir);
if (proj <= 0) continue;
const perpDistSq = ballToCue.magnitude() ** 2 - proj ** 2;
const totalRadius = cueBall.radius + ball.radius;
if (perpDistSq < totalRadius ** 2) {
const distToImpact = proj - Math.sqrt(totalRadius ** 2 - perpDistSq);
if (distToImpact >= 0 && distToImpact < closestHit.dist) {
closestHit = { dist: distToImpact, ball: ball };
}
}
}
if (closestHit.ball) {
const targetBall = closestHit.ball;
const cueImpactPos = cueBall.pos.add(aimDir.multiply(closestHit.dist));
const targetDir = targetBall.pos.subtract(cueImpactPos).normalize();
const startPoint = targetBall.pos;
const endPoint = startPoint.add(targetDir.multiply(targetBall.radius * 2));
ctx.save();
ctx.beginPath();
ctx.moveTo(startPoint.x, startPoint.y);
ctx.lineTo(endPoint.x, endPoint.y);
ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
ctx.lineWidth = 2;
ctx.stroke();
ctx.restore();
}
}
};
const AI = {
isPathClear(startPos, endPos, ballToIgnore1, ballToIgnore2) {
const lineVec = endPos.subtract(startPos);
const lineMagSq = lineVec.x ** 2 + lineVec.y ** 2;
for (const ball of balls) {
if (ball.isSunk || ball === ballToIgnore1 || ball === ballToIgnore2) continue;
const ballVec = ball.pos.subtract(startPos);
const t = ballVec.dot(lineVec) / lineMagSq;
if (t > 0.01 && t < 0.99) {
const closestPoint = startPos.add(lineVec.multiply(t));
const distSq = (closestPoint.x - ball.pos.x) ** 2 + (closestPoint.y - ball.pos.y) ** 2;
if (distSq < (ball.radius * 2) ** 2) return false;
}
}
return true;
},
takeShot() {
if (gameState !== 'AWAITING_INPUT' || Game.currentPlayer !== ai) return;
const bestShot = this.findBestShot();
if (bestShot) {
const finalDir = bestShot.aimPos.subtract(balls[0].pos).normalize();
balls[0].vel = finalDir.multiply(bestShot.power);
} else {
Game.updateStatus('The AI ​​has no legal moves and passes the turn.');
setTimeout(() => Game.switchTurn(false), 1000);
return;
}
gameState = 'SHOT_IN_PROGRESS';
Physics.shotData = {
sunkBalls: [],
firstHit: null,
hitRailAfterContact: false
};
balls.forEach(b => (b.hitRail = false));
},
findBestShot() {
let bestShot = {
score: -Infinity,
target: null,
pocket: null,
aimPos: null,
power: 0
};
const cueBall = balls[0];
let targetBalls = [];
if (Game.isTableOpen) {
targetBalls = balls.filter(b => !b.isSunk && b.type !== '8ball' && b.type !== 'cue');
} else {
targetBalls = balls.filter(b => b.type === ai.ballType && !b.isSunk);
if (targetBalls.length === 0) {
targetBalls = balls.filter(b => b.type === '8ball' && !b.isSunk);
}
}
if (targetBalls.length === 0) return null;
for (const target of targetBalls) {
for (const pocket of pockets) {
let aimTargetPos = pocket.pos;
if (!pocket.isCorner) {
const tableEdgeY = pocket.pos.y < canvas.height / 2 ? 0 : canvas.height;
aimTargetPos = new Vector(canvas.width / 2, tableEdgeY);
}
const targetToPocketDir = aimTargetPos.subtract(target.pos).normalize();
const aimPos = target.pos.subtract(targetToPocketDir.multiply(cueBall.radius + target.radius));
if (!this.isPathClear(cueBall.pos, aimPos, cueBall, target)) continue;
if (!this.isPathClear(target.pos, pocket.pos, target, cueBall)) continue;
const cueToAimDist = cueBall.pos.subtract(aimPos).magnitude();
const targetToPocketDist = target.pos.subtract(pocket.pos).magnitude();
const distanceScore = 1 / (cueToAimDist + targetToPocketDist);
const cueToAimDir = aimPos.subtract(cueBall.pos).normalize();
const angle = Math.acos(cueToAimDir.dot(targetToPocketDir));
const angleBonus = Math.pow(1 - (angle / Math.PI), 2);
let score = (1000 + distanceScore * 200) * angleBonus;
if (target.type === '8ball') score *= 2;
if (score > bestShot.score) {
const power = Math.min(10 + (cueToAimDist + targetToPocketDist) / 30, 35);
bestShot = { score, target, pocket, aimPos, power };
}
}
}
if (bestShot.score === -Infinity) {
Game.updateStatus('AI doesn\'t find any good holes. Plays positionally.');
for (const target of targetBalls) {
const tableCenter = new Vector(canvas.width / 2, canvas.height / 2);
const targetToCenterDir = tableCenter.subtract(target.pos).normalize();
const aimPos = target.pos.add(targetToCenterDir.multiply(cueBall.radius + target.radius));
if (!this.isPathClear(cueBall.pos, aimPos, cueBall, target)) continue;
const cueToTargetDist = cueBall.pos.subtract(target.pos).magnitude();
const score = 200 - cueToTargetDist;
if (score > bestShot.score) {
bestShot = { score, target, pocket: null, aimPos, power: 15 };
}
}
}
if (bestShot.score === -Infinity) {
for (const target of targetBalls) {
const dir = target.pos.subtract(cueBall.pos).normalize();
const aimPos = target.pos.subtract(dir.multiply(cueBall.radius + target.radius));
const score = 100 - cueBall.pos.subtract(target.pos).magnitude();
if (score > bestShot.score) {
bestShot = { score, target, pocket: null, aimPos, power: 10 };
}
}
}
return bestShot.score > -Infinity ? bestShot : null;
},
placeBall(isBreakFoul) {
let bestPlacement = {
score: -Infinity,
position: null
};
const cueBall = balls[0];
const originalPos = cueBall.pos;
const step = cueBall.radius * 3;
const startX = cueBall.radius;
const endX = isBreakFoul ? canvas.width / 4 - cueBall.radius : canvas.width - cueBall.radius;
for (let x = startX; x < endX; x += step) {
for (let y = cueBall.radius; y < canvas.height; y += step) {
const testPos = new Vector(x, y);
const isOverlapping = balls.slice(1).some(b => !b.isSunk && testPos.subtract(b.pos).magnitude() < cueBall.radius * 2.1);
if (isOverlapping) continue;
cueBall.pos = testPos;
const shot = this.findBestShot();
if (shot && shot.score > bestPlacement.score) {
bestPlacement = {
score: shot.score,
position: testPos
};
}
}
}
if (bestPlacement.position) {
cueBall.pos = bestPlacement.position;
} else {
cueBall.pos = new Vector(isBreakFoul ? canvas.width / 8 : canvas.width / 4, canvas.height / 2);
}
cueBall.pos = bestPlacement.position || originalPos;
gameState = 'AWAITING_INPUT';
Game.updateStatus('The AI\'s turn.');
setTimeout(() => this.takeShot(), 1000);
},
};
playAgainBtn.addEventListener('click', () => Game.startNewGame());
howToPlayBtn.addEventListener('click', () => (rulesModal.style.display = 'block'));
closeModalBtn.addEventListener('click', () => (rulesModal.style.display = 'none'));
window.addEventListener('click', event => {
if (event.target == rulesModal) rulesModal.style.display = 'none';
});
Input.init();
window.addEventListener('resize', () => Game.handleResize());
Game.handleResize();
Game.startNewGame();
});
</script>
</body>
</html>
